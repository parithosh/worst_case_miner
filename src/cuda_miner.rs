// CUDA-accelerated mining module
use log::info;

#[cfg(feature = "cuda")]
extern "C" {
    fn cuda_mine_storage_slot(
        target_prefix: *const u8,
        required_nibbles: i32,
        base_slot: u64,
        result_address: *mut u8,
        result_storage_key: *mut u8,
        found: *mut bool,
        blocks: i32,
        threads_per_block: i32,
        attempts_per_thread: u64,
        start_nonce: u64,
    );

    fn cuda_verify_keccak(
        test_address: *const u8,
        base_slot: u64,
        result_storage_key: *mut u8,
    );

    fn cuda_debug_prng(
        seed: u64,
        base_slot: u64,
        result_address: *mut u8,
        result_storage_key: *mut u8,
    );
}

/// Verify CUDA keccak produces same output as CPU
#[cfg(feature = "cuda")]
pub fn verify_cuda_keccak(address: &[u8; 20], base_slot: u64) -> [u8; 32] {
    let mut result = [0u8; 32];
    unsafe {
        cuda_verify_keccak(address.as_ptr(), base_slot, result.as_mut_ptr());
    }
    result
}

/// Debug: get the address and storage key generated by CUDA PRNG for a given seed
#[cfg(feature = "cuda")]
pub fn debug_cuda_prng(seed: u64, base_slot: u64) -> ([u8; 20], [u8; 32]) {
    let mut address = [0u8; 20];
    let mut storage_key = [0u8; 32];
    unsafe {
        cuda_debug_prng(seed, base_slot, address.as_mut_ptr(), storage_key.as_mut_ptr());
    }
    (address, storage_key)
}

#[cfg(feature = "cuda")]
pub fn mine_with_cuda(
    target_prefix: &[u8; 32],
    required_nibbles: usize,
    base_slot: u64,
) -> Option<([u8; 20], [u8; 32])> {
    let mut result_address = [0u8; 20];
    let mut result_storage_key = [0u8; 32];
    let mut found = false;

    // CUDA configuration - 256 blocks is empirically optimal for this kernel
    // Testing showed that scaling with SM count (e.g., 510 or 1360 blocks)
    // causes 50%+ slowdown, likely due to memory contention on the found flag
    // and wasted work after a match is found
    let blocks = 256;
    let threads_per_block = 256;

    // Scale attempts based on required nibbles
    // Each nibble adds 4 bits of difficulty (16x harder)
    // Base: 100k attempts, scale up for higher nibble counts
    let attempts_per_thread: u64 = match required_nibbles {
        0..=3 => 1_000,       // Very easy, just for testing
        4..=5 => 10_000,
        6 => 100_000,
        7 => 1_000_000,
        8 => 10_000_000,
        9 => 50_000_000,
        10 => 100_000_000,
        _ => 200_000_000,
    };

    // Calculate max iterations to attempt before giving up
    // For very high nibble counts, we may need multiple kernel launches
    let max_iterations = match required_nibbles {
        0..=7 => 1,
        8 => 5,
        9 => 20,
        10 => 50,
        11 => 100,
        _ => 200,
    };

    let total_attempts_per_iteration = blocks as u64 * threads_per_block as u64 * attempts_per_thread;

    info!(
        "Mining with CUDA: {} blocks, {} threads/block, {} attempts/thread ({:.2}B attempts/iteration, max {} iterations)",
        blocks, threads_per_block, attempts_per_thread,
        total_attempts_per_iteration as f64 / 1_000_000_000.0,
        max_iterations
    );
    info!(
        "Target prefix (first {} nibbles): 0x{}",
        required_nibbles,
        hex::encode(&target_prefix[..(required_nibbles + 1) / 2])
    );

    // Calculate attempts per iteration to compute start_nonce for each iteration
    let attempts_per_iteration = blocks as u64 * threads_per_block as u64 * attempts_per_thread;

    for iteration in 0..max_iterations {
        if iteration > 0 && iteration % 10 == 0 {
            info!("CUDA iteration {}/{}", iteration, max_iterations);
        }

        // Each iteration starts where the previous one left off
        let start_nonce = iteration as u64 * attempts_per_iteration;

        unsafe {
            cuda_mine_storage_slot(
                target_prefix.as_ptr(),
                required_nibbles as i32,
                base_slot,
                result_address.as_mut_ptr(),
                result_storage_key.as_mut_ptr(),
                &mut found as *mut bool,
                blocks,
                threads_per_block,
                attempts_per_thread,
                start_nonce,
            );
        }

        if found {
            if iteration > 0 {
                info!("CUDA found match on iteration {}", iteration + 1);
            }
            return Some((result_address, result_storage_key));
        }
    }

    None
}

#[cfg(not(feature = "cuda"))]
pub fn mine_with_cuda(
    _target_prefix: &[u8; 32],
    _required_nibbles: usize,
    _base_slot: u64,
) -> Option<([u8; 20], [u8; 32])> {
    panic!("CUDA support not enabled. Build with --features cuda");
}

/// Check if CUDA is available
pub fn cuda_available() -> bool {
    #[cfg(feature = "cuda")]
    {
        // In a real implementation, we'd check if CUDA runtime is available
        true
    }
    #[cfg(not(feature = "cuda"))]
    {
        false
    }
}
